{"ast":null,"code":"import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearEncoding, LinearFilter, NearestFilter, RGBEEncoding, RGBEFormat, RGBFormat, UnsignedByteType } from 'three'; // https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\n  parse(buffer) {\n    const\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n          rgbe_write_error = 2,\n          rgbe_format_error = 3,\n          rgbe_memory_error = 4,\n          rgbe_error = function (rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n          RGBE_VALID_FORMAT = 2,\n          RGBE_VALID_DIMENSIONS = 4,\n          NEWLINE = '\\n',\n          fgets = function (buffer, lineLimit, consume) {\n      const chunkSize = 128;\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        \tbyteCode = m.charCodeAt(i);\n        \tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        \telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        \tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function (buffer) {\n      // regexes to parse header info fields\n      const magic_token_re = /^#\\?(\\S+)/,\n            gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n            dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n            // RGBE format header struct\n      header = {\n        valid: 0,\n\n        /* indicate which fields are valid */\n        string: '',\n\n        /* the actual header string */\n        comments: '',\n\n        /* comments found in header */\n        programtype: 'RGBE',\n\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        format: '',\n\n        /* RGBE format, default 32-bit_rle_rgbe */\n        gamma: 1.0,\n\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        exposure: 1.0,\n\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n      let line, match;\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, 'no header found');\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, 'bad initial token');\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + '\\n';\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + '\\n';\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + '\\n';\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, 'missing format specifier');\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n      }\n\n      return header;\n    },\n          RGBE_ReadPixels_RLE = function (buffer, w, h) {\n      const scanline_width = w;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n      }\n\n      const data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n      }\n\n      let offset = 0,\n          pos = 0;\n      const ptr_end = 4 * scanline_width;\n      const rgbeStart = new Uint8Array(4);\n      const scanline_buffer = new Uint8Array(ptr_end);\n      let num_scanlines = h; // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        let ptr = 0,\n            count;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          const isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, 'bad scanline data');\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            const byteValue = buffer[pos++];\n\n            for (let i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        const l = scanline_width; //scanline_buffer.byteLength;\n\n        for (let i = 0; i < l; i++) {\n          let off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0; // clamping to 65504, the maximum representable value in float16\n\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n    };\n\n    const byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    const rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      const w = rgbe_header_info.width,\n            h = rgbe_header_info.height,\n            image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        let data, format, type;\n        let numElements;\n\n        switch (this.type) {\n          case UnsignedByteType:\n            data = image_rgba_data;\n            format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n            type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            numElements = image_rgba_data.length / 4;\n            const floatArray = new Float32Array(numElements * 3);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            data = floatArray;\n            format = RGBFormat;\n            type = FloatType;\n            break;\n\n          case HalfFloatType:\n            numElements = image_rgba_data.length / 4;\n            const halfArray = new Uint16Array(numElements * 3);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\n            }\n\n            data = halfArray;\n            format = RGBFormat;\n            type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n\n}\n\nexport { RGBELoader };","map":{"version":3,"names":["DataTextureLoader","DataUtils","FloatType","HalfFloatType","LinearEncoding","LinearFilter","NearestFilter","RGBEEncoding","RGBEFormat","RGBFormat","UnsignedByteType","RGBELoader","constructor","manager","type","parse","buffer","RGBE_RETURN_FAILURE","rgbe_read_error","rgbe_write_error","rgbe_format_error","rgbe_memory_error","rgbe_error","rgbe_error_code","msg","console","error","RGBE_VALID_PROGRAMTYPE","RGBE_VALID_FORMAT","RGBE_VALID_DIMENSIONS","NEWLINE","fgets","lineLimit","consume","chunkSize","p","pos","i","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBE_ReadHeader","magic_token_re","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","line","match","charAt","parseFloat","parseInt","RGBE_ReadPixels_RLE","w","h","scanline_width","Uint8Array","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","count","isEncodedRun","byteValue","set","l","off","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","Math","pow","RGBEByteToRGBHalf","toHalfFloat","min","byteArray","rgbe_header_info","image_rgba_data","data","numElements","floatArray","Float32Array","j","halfArray","setDataType","value","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY"],"sources":["/home/malf/code/game-demo/client/node_modules/three/examples/jsm/loaders/RGBELoader.js"],"sourcesContent":["import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearEncoding,\n\tLinearFilter,\n\tNearestFilter,\n\tRGBEEncoding,\n\tRGBEFormat,\n\tRGBFormat,\n\tUnsignedByteType\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* return codes for rgbe routines */\n\t\t\t//RGBE_RETURN_SUCCESS = 0,\n\t\t\tRGBE_RETURN_FAILURE = - 1,\n\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn RGBE_RETURN_FAILURE;\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tif ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {\n\n\t\t\tconst w = rgbe_header_info.width,\n\t\t\t\th = rgbe_header_info.height,\n\t\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\t\t\tif ( RGBE_RETURN_FAILURE !== image_rgba_data ) {\n\n\t\t\t\tlet data, format, type;\n\t\t\t\tlet numElements;\n\n\t\t\t\tswitch ( this.type ) {\n\n\t\t\t\t\tcase UnsignedByteType:\n\n\t\t\t\t\t\tdata = image_rgba_data;\n\t\t\t\t\t\tformat = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\t\t\t\t\t\ttype = UnsignedByteType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst floatArray = new Float32Array( numElements * 3 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = floatArray;\n\t\t\t\t\t\tformat = RGBFormat;\n\t\t\t\t\t\ttype = FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst halfArray = new Uint16Array( numElements * 3 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = halfArray;\n\t\t\t\t\t\tformat = RGBFormat;\n\t\t\t\t\t\ttype = HalfFloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.error( 'THREE.RGBELoader: unsupported type: ', this.type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\twidth: w, height: h,\n\t\t\t\t\tdata: data,\n\t\t\t\t\theader: rgbe_header_info.string,\n\t\t\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\t\t\texposure: rgbe_header_info.exposure,\n\t\t\t\t\tformat: format,\n\t\t\t\t\ttype: type\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase UnsignedByteType:\n\n\t\t\t\t\ttexture.encoding = RGBEEncoding;\n\t\t\t\t\ttexture.minFilter = NearestFilter;\n\t\t\t\t\ttexture.magFilter = NearestFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}